# CarND-Controls-PID Writeup
Self-Driving Car Engineer Nanodegree Program 

[![Udacity - Self-Driving Car NanoDegree](https://s3.amazonaws.com/udacity-sdc/github/shield-carnd.svg)](http://www.udacity.com/drive)


## Overview

-------------------------------------------------

This System Integration project implements a software suite that could drive an autonomous vehicle in the [simulator](https://github.com/udacity/self-driving-car-sim/releases) or in real world with some limitations (e.g. in a controlled safe environment).

The system is based on the robotic operational system [ROS](https://www.ros.org/) and contains an ensemble of ROS nodes, performing various tasks for controlling the vehicle:

[architecture]: ./imgs/final-project-ros-graph-v2.png "Vehicle control system ROS nodes"
![][architecture]

#### Nodes

###### Waypoint loader

Loads base waypoints from a CSV file. During a real world driving session, the base waypoints would be generated by a route planner using some kind of maps such as Google, OSM, etc. In scope of this project there are a set of predefined waypoints around the circular track of the simulator scene. The loaded waypoints are being published into the `/base_waypoints` topic. Also the waypoint loader sets the desired vehicle speed.

###### Waypoint updater

This node uses the base waypoints from the `/base_waypoints` topic, and also information about the current position and velocity of the vehicle, and some information about surrounding from, respectively, `/current_pose` and `/traffic_waypoint` topics. Based on the desired route (base wapoints), current vehicle position and the surroundungs, this node generates a list of updated waypoints to drive safely and comfortably. These "final" waypoints most of the time are just copies of the base ones, but might have different desired speed and coordinates in case of an obstacle is ahead or a traffic light demands to stop. THe final waypoints are then being published to the `/final_waypoints` topic

###### Waypoint follower

To follow the final waypoints, the vehicle must operate its steering and brake/throttle. The waypoint follower node generates corresponding commands to the vehicle driving circuits, using the current vehicle position and velocities and the final waypoint list. The commands are encoded in TwistStamped format and being published into the `/twist_cmd` topic.

###### Drive-by-wire (DBW) node and twist controller

This node implements the practical control of the vehicle's steering, throttle and brake, according to the twist commands, generated by the waypoint follower. The node gathers information about current vehicle state from the `/current_velocity` topic and takes a command from the `/twist_cmd` topic. Then, using a PID controller, a particular value of the throttle/brake is generated to maintain desired speed, and another PID controller provides a particular value of a steering angle to reach the desired angular velocity and/or car heading. The node operates (e.g. sends steering, throttle, brake commands to, respectively, `/vehicle/steering_cmd`, `/vehicle/throttle_cmd`, `/vehicle/brake_cmd`) only if there has been an enabling message published into `/vehicle/dbw_enabled`.

###### Traffic light detector

This node takes a color image from the `/image_color` topic and detects if there is a traffic light in the image, and what is the state of the traffic light (red, green, yellow, ...). Also there is a helper information being published to the `/vehicle/traffic_lights` topis by the simulator, so during the driving in the simulated environment it is possible to validate the detected state of the traffic light.

###### Bridge/server or cppbridge

This node serves as a bridge between the simulator and other ROS nodes, or a bridge between the ROS nodes and a real vehicle CAN controlling device. Unfortunately, due to significant changes in Python packages during last years, I was not able to run the bridge server successfuly, so I have reimplemented this functionality in a `cppbridge` node, using C++ and uWS library. The corresponding code can be found at `cppbridge` branch of the repository, in the `ros/src/cppbridge/...` folders. *Note: this code is not compilable within the Udacity workspace, so I have removed it from the master/develop branches*. The cpp implementation does exactly the same as the original Python one, so I wouldn't review it here separately.
The bridge takes the commands from the `/vehicle/steering_cmd`, `/vehicle/throttle_cmd`, `/vehicle/brake_cmd` topics, waypoints info (to render them on the scene) from the `/final_waypoints` topic, and sends the corresponding TCP packets to the simulator. Also, the server receives TCP packets with the vehicle status and surroundings info, and then publishes this information into the `/vehicle/dbw_enabled`, `/current_pose`, `/current_velocity`, `/image_color` topics.


## Implementation details

-------------------------------------------------

### Traffic light detection

My approach to:
* tl_detector
* dbw node and twist contr
    twist brake force computing - throttle wiggle avoidance
    lowpass filter for Yaw
* wpt updater
    why less wpts
    frequency adjustment

Detection (optional)
* dataset gathering
    from sim
        photos, samples
* image preprocessing (top part, colorization)
    camera is watching the sky and never the road, thus it's ok
* model architecture
    opencv classifier, no models
    describe the pictures (with illustrations of various techniques)
    * any chance to make a real road photo?
        yes, the demo illustration now available
    
    Video link:
    https://youtu.be/qA7bLBL-geI


Rubric points:
* The code is built successfully and connects to the simulator.
* Waypoints are published to plan Carla’s route around the track.
* Controller commands are published to operate Carla’s throttle, brake, and steering.
* Successfully navigate the full track more than once.

Video? (....)

